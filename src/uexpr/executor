

from typing import Any
from .rex import *
from .instance import Instance
from .coverage import Coverage
import datetime

# z3.Implies
LABELED_NULL = {
    'INT' : 6789,
    'REAL' : 0.6789,
    'STRING' : 'NULL',
    'BOOLEAN' : 'NULL',
    'DATETIME' : datetime.datetime(1970, 1, 1, 0, 0, 0),
    'DATE' : datetime.date(1970, 1, 1),
}

class Executor:
    '''
        An executor will traverse UExper and generate execution branches. Use as:
        execute = Executor()
        execute(query_plan, instance)
    '''
    def __init__(self, path):
        self.path = path
        self.coverage = Coverage()

    def __call__(self, root, instance, *args: Any, **kwds: Any) -> Any:
        return self.execute(root = root,  instance = instance)

    def execute(self, root, **kwargs) -> Any:
        fname = 'execute_%s' % root.key
        func = getattr(self, fname)
        return func(root, **kwargs)

    def execute_scan(self, operator: Step, **kwargs):
        instance: Instance = kwargs.get('instance')
        inputs = instance.get_table(operator.table)
        output = []
        for row in inputs:
            output.append(row)
            self.coverage.traceit(operator.key, 1, 'path')
            # relations.append(Relation(this = row.multiplicity, table = operator.table))
        # self.path.which_branch(operator, relations)
        return output

    def execute_project(self, operator: Step, **kwargs):
        inputs = self.execute(operator.this, **kwargs)
        output = []
        for row in inputs:
            projections = [self.execute(project, row = row) for project in operator.projections]
            output.append(projections)
            self.coverage.traceit(operator.key, line= 0, event= 'path')
        return output

    def execute_filter(self, operator: Step, **kwargs):
        inputs = self.execute(operator.this, **kwargs)
        outputs = []
        smt_exprs = []
        for row in inputs:
            sat = self.execute(operator.condition, row = row, **kwargs)
            if sat:
                outputs.append(row)
            smt_exprs.append((sat, row.multiplicity))
        self.path.update_branch(operator, smt_exprs)
        return outputs
    
    def execute_join(self, operator: Step, **kwargs):
        left_inputs = self.execute(operator.left, **kwargs)
        right_inputs = self.execute(operator.right, **kwargs)
        outputs = []
        join_type = operator.kind

        ### Process Inner Join
        if join_type == 'inner':
            for lrow in left_inputs:
                smt_exprs = []
                for rrow in right_inputs:
                    row = lrow * rrow
                    sat = self.execute(operator.condition, row = row, **kwargs)
                    if sat:
                        outputs.append(row)
                    smt_exprs.append((sat, row.multiplicity))
                self.path.update_branch(operator, smt_exprs)

        ### Process Left Join


        ### Process Right Join
        
        
        return outputs

    def execute_aggregate(self):
        raise NotImplementedError

    def execute_sort(self):
        raise NotImplementedError
    
    def execute_cast(self, operator, **kwargs):
        raise NotImplementedError
        # this = self.execute(operator.this, **kwargs)
        # return this

    def execute_like(self, operator, **kwargs):
        raise NotImplementedError
        # left = self.execute(operator.this, **kwargs)
        # formats = self.execute(operator.expression, **kwargs)
        # return left.like(formats)

    def execute_is_null(self, operator, **kwargs):
        raise NotImplementedError
        # this = self.execute(operator.this, **kwargs)
        # return this.is_null()

    def execute_neg(self, operator, **kwargs):
        this = self.execute(operator.this, **kwargs)
        return this.__neg__()
   
    def execute_not(self, operator, **kwargs):
        this = self.execute(operator.this, **kwargs)
        return this.__not__()

    def execute_or(self, operator: exp, **kwargs):
        left = self.execute(operator.this, **kwargs)
        right = self.execute(operator.expression, **kwargs)
        return left.logical(right, 'or')
    
    def execute_and(self, operator, **kwargs):
        left = self.execute(operator.this, **kwargs)
        right = self.execute(operator.expression, **kwargs)
        if left.value:
            self.coverage.traceit(operator.find_ancestor(Step), line= 1, event= 'predicate')
        if right.value:
            self.coverage.traceit(operator.find_ancestor(Step), line= 2, event= 'predicate')
        return left.logical(right, 'and')

    def execute_column(self, operator,**kwargs):
        row = kwargs.get('row')
        return row[int(operator.args.get('ref'))]

    def execute_literal(self, operator, **kwargs):
        if operator.is_string:
            return str(operator.this)
        elif operator.is_number:
            return int(operator.this)
        # operator.datatype.is_type(exp.DataType.is_number)
        return operator.this

ops =[("gt", ">" ),\
      ("gte", ">="),\
      ("lt", "<"),\
      ("lte", "<="),\
      ("eq", "=="),\
      ("neq", "!=")]

def make_method(method, op):
    code = "def %s(self, operator, **kwargs):\n" % method
    code += "   left = self.execute(operator.this, **kwargs)\n"
    code += "   right = self.execute(operator.expression, **kwargs)\n"
    
    code += "   result = left %s right \n" % op
    code += "   return result"
    locals_dict = {}
    exec(code, globals(), locals_dict)
    setattr(Executor, method, locals_dict[method])

for (name, op) in ops:
    method = "execute_%s" % name
    make_method(method, op)