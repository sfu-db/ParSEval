import logging
from typing import Dict
from .executor import Executor
from src.uexpr.planner import Plan
from .instance import Instance
from .uexpr_to_constraint import UExprToConstraint
from ..symbols.solver import Solver

logger = logging.getLogger('src.main')
class InstanceGenerator:
    '''
        Core class to generate different databases.
        Given a query and schema, we first parse the query to get runnable UExpr and initialize positive branch.
    '''
    def __init__(self, workspace, schema, query, initial_values, dialect = 'sqlite') -> None:
        self.workspace = workspace
        self.dialect = dialect
        self.schema = schema
        self.querr = query
        self.plan = Plan(schema= schema, query= query, dialect= dialect)
        self.initial_values = initial_values
        self.cases = []
        self.context = ({}, [])
        self.new_constraints = []
        self.path = UExprToConstraint(lambda c: self.add_constraint(c))
        # self.path = self.context[1]
        self.executor = Executor(self.path)

        self.solver = Solver()

    def add_constraint(self, c):
        self.new_constraints.append(c)

    def create_instance(self, initial_values, size = 5) -> Instance:
        instance = Instance.create(self.schema, name = f'instance_size{size}', dialect= self.dialect)
        for table_name in list(instance._tables.keys()):
            for _ in range(size):
                instance.append_tuple(table_name, context= self.context, initial_values= {})
        return instance
    
    def generate(self, max_iterations, size = 2, timeout = None):
        

        ...


    def print_coverage(self):
        ...
    
    def _update_concrete(self, values: Dict):
        for key, value in values.items():
            if key in self.context[0]:
                self.context[0][key].value = value
        
    def _one_execution(self):
        tries = 0
        size = 2
        initial_values = {}
        instance = self.create_instance(initial_values, size)
        while tries < 2:
            self.path.reset(None)
            result = self.executor(self.plan.root, instance)
            if not self.new_constraints:
                logger.info('no new constraints')
                break

            if result:
                # logger.info(result)
                break

            paths = self.new_constraints.pop()

            logger.info(paths)
            sat, solutions = self.solver._find_model([paths], instance.get_db_constraints())
            
            if sat == 'Gave up':
                break
            elif sat == 'No Solutions':
                size += 1
            elif sat == 'sat':
                self._update_concrete(solutions)
                logger.info(solutions)
            tries += 1
            
    def _is_explored_completed(self):
        ...
